# DDA #
_practicals are done in c++ editor_
 
**The practical contains nine questions**

1. 
1.1 Insertion sort with its Total no of comparison
  Insertion sort has time complexity .
    
* Best case - Ω(n)
* Worst case - O(n^2)
 
1.2 Merge sort with its total no of comparison.
     
* Best case- Ω(n log(n))
* Worst case- O(n log(n))

2. Heap sort with total no of comparison
 
* Best case- Ω(n log(n))
* Worst case- O(n log(n))

3. Randomize quick sort with total no of comparison

* Best case - Ω(n log(n))
* Worst case - O(n^2)

4. Radix sort

* Best case- Ω(nk)
* Worst case- O(nk)
 
**Tabular Comparison of all above sorting technique** 

|Sorting.      | best case| Worst case
|-----------   |----------|----------
|Insertion sort|  Ω(n)    |O(n^2)
|.             |.         |.  
|Merge sort.   |Ω(nlog(n))|O(n log(n))
|.             |.         |
|Heap sort.    |Ω(nlog(n))|O(n log(n))
|.             |.         |
|Rand quicksort|Ω(nlog(n))|O(n^2)
|.             |.         |
|Radix sort.   |  Ω(nk)   | O(nk)

_Note:- If time complexity is same we compare with space complexity_

5. Red-black tree with following operations
 
 * Additional of nodes
 * Deletion of nodes
 * Search for a number and show color of node
 
Red- black tree is the modification of other tree
While implementation the color of the nodes should be blanced
To make the red-black tree we need to follow some set of rules.
 
_If the program gives null pointer error then be sure to do compiler setting to c++11_

6.Lcs program (Longest common subsequence)
  
* It the problem of finding 
  the longest subsequence common to all sequences in a set of sequences (often just two sequences).
 
7.Breadth first search
 
* BFS is used to find single source shortest path in an unweighted graph.
Uses queue data structure and goes in breadthward direction for searching
 
8.Depth first search
 
* It goes in depthward direction for searching .it almost visit all the vertices 
It follow stack data structure.

9. Minimum spanning tree
 
It has two algorithms 
  
9.1 kruskal's algorithm

* It builds the spanning tree by adding edges one by one into a growing spanning tree. Kruskal's algorithm follows 
greedy approach as in each iteration it finds an edge which has least weight and add it to the growing spanning tree.
 
9.2 Prim's algorithm
 
* It also use Greedy approach to find the minimum spanning tree.
In Prim’s Algorithm we grow the spanning tree from a starting position.
                 
***               
>Thankyou
---                
